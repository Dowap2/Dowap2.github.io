# 개요

최근 웹 퍼포먼스를 좋게하면 어떻게 해야하는가라는 질문과
내가 직접 실천한 웹 퍼포먼스에 관한 이야기를 하는 기회가 있었다.

웹 퍼포먼스를 좋게하는 방법을 몇가지 알고있긴했지만 잘 대답했는지 잘모르겠다.
또 내가 코드를 리펙토링하다가 개선을 한 적은 있어도 처음부터 웹 퍼포먼스를 생각했는가에 대한 반성도 하게 되었다.

# 웹 퍼포먼스에 대하여

그전에 프론트에서의 웹 퍼포먼스를 중심적으로 작성할 예정입니다.

웹 퍼포먼스는 간단하게 생각하면 웹이 얼마나 잘 작동하고 빠르게 작동하는가로 생각하면 편할 것 같다.
페이지 로드를 얼마나 빠르게하는가? 주어진 기능에 대하여 빠르고 올바르게 작동을 하는가? 정도가 될 것 같다.

클라이언트에서 최적화 하는 방법에 대하여 알아보자면

HTML 렌더링 중에 자바스크립트 즉 <script> 태그를 만나게 되는 경우
HTML 파싱을 중지하고 js엔진으로 제어권한을 넘기게 된다.
위 과정이 끝나면 다시 파싱이 중단된 시점에서 파싱을 시작한다.
이때문에 스크립트는 HTML 파싱이 끝난 body태그 뒤쪽에 작성한다.

스크립트 파일을 파싱 전 즉 body태그 앞에서 로드 하는 경우
스크립트를 읽는 동안 브라우저는 다른 작업을 수행하지않기 때문에
레이아웃이 구성되지않은 뷰를 사용자에게 보여주게 된다.
이는 사용자에게 불쾌감을 줄 수 있다.

위 방법을 작성하다보니 클라이언트에서의 최적화는 브라우저 렌더링에 관해 잘 알고 있어야 할 것 같다는 생각이 들었다.

# 브라우저 렌더링

간단하게 설명하자면

1. 서버에서 HTML과 CSS를 다운받습니다.
2. 위 두 파일을 Object 모델로 제작합니다. 이를 통해 CSSOM과 DOM Tree가 만들어집니다.
3. 이 둘로 Render Tree를 만듭니다.
4. 각 노드를 위치과 크기 계산을 합니다.
5. 실제화면에 그립니다.

위 과정중에서 3번에 대하여 먼저 알아봅시다.

### 렌더트리

렌더트리는 실제 화면에 표현되는 요소로 구성이 됩니다.
반대로 말하면 실제 화면에 표시되지않는 친구들은 요소에 포함이 되지않는다는 이야기입니다.

ex) display: none은 실제 화면에 포함되지않습니다. 그러므로 렌더트리에서 제외됩니다. 하지만
visibility: invisible 은 공간을 차지하기때문에 포함됩니다.

이를 생각하며 필요하지않다면 요소에 포함되지않도록 하는 것이 렌더트리를 구성하는 과정에서 이점이 있다고 생각합니다.

### reflow와 repaint

이는 4번과 5번을 함께 포함합니다.

예를 들어 화면에 변경이 있을 때 크기 위치등을 수정하게 되면 4번 레이아웃과정이 실행이 됩니다.
그럴 경우 4번 5번 과정이 다시 실행되게 됩니다.

하지만 크기 대신 scale등의 속성을 이용하여 두배로 늘리거나 색상을 변경하는 경우에는 크기 위치등이 변경되지않기때문에
레이아웃 과정을 실행할 필요 없이 페인트 과정만 실행됩니다.

그렇기 때문에 이를 통해 레이아웃(reflow) 과정이 일어나지않도록 수정하는 것도 퍼포먼스를 올리는 방법이 될 수 있습니다.

# React의 Virtual DOM에 대하여

React를 사용하면 웹 페이지 성능이 좋아지는데 이는 Virtual DOM이 있기 때문입니다.

DOM에 접근하여 여러번의 속성변화 스타일 변화등을 수행하는 경우 그에 따른 여러번의 reflow repaint가 일어나는데
이를 Virtual DOM에서는 한번에 묶어서 보내서 변경을 하며
변경된 부분만 확인하여 이를 수정합니다.
